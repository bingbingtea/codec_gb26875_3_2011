package codec

import (
	"bytes"
	"runtime"
	"sync"
	"testing"
	"time"

	"github.com/shootingfans/codec_gb26875_3_2011/constant"
	"github.com/shootingfans/codec_gb26875_3_2011/utils"

	"github.com/stretchr/testify/assert"
)

func TestReaderDecoder(t *testing.T) {
	t.Run("test close when C not empty", func(t *testing.T) {
		buf := bytes.NewBuffer(make([]byte, 0))
		rd := NewReaderDecoder(buf)
		var wg sync.WaitGroup
		wg.Add(2)
		go func() {
			defer wg.Done()
			for range [2][]int{} {
				select {
				case p, ok := <-rd.C:
					if !ok {
						return
					}
					assert.EqualValues(t, p, &constant.Packet{
						Header: constant.Header{
							Version:   0x101,
							Timestamp: utils.Bytes2Timestamp([]byte{0x18, 0x0d, 0x11, 0x16, 0x0a, 0x14}),
							Target:    0x010203040506,
						},
						Action: constant.ActionOfSendData,
						EquipmentStates: []constant.EquipmentStateInfo{
							{
								Equ: constant.Equipment{
									Ctrl: constant.Controller{
										Type: constant.ControllerTypeOfFireAlarmSystem,
										Addr: 0x03,
									},
									Addr: 0x0600d9,
								},
								Flag:        0x02,
								Description: "这是一个转码测试",
								Timestamp:   utils.Bytes2Timestamp([]byte{0x30, 0x12, 0x13, 0x01, 0x08, 0x14}),
							},
						},
						AppData: []byte{0x02, 0x01, 0x01, 0x03, 0x00, 0xd9, 0x00, 0x06, 0x00, 0x02, 0x00, 0xd5, 0xe2, 0xca, 0xc7, 0xd2, 0xbb, 0xb8, 0xf6, 0xd7, 0xaa, 0xc2, 0xeb, 0xb2, 0xe2, 0xca, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x12, 0x13, 0x01, 0x08, 0x14},
					})
				}
			}
		}()
		go func() {
			defer wg.Done()
			buf.Write([]byte{0x40, 0x40, 0x00, 0x00, 0x01, 0x01, 0x18, 0x0d, 0x11, 0x16, 0x0a, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
			buf.Write([]byte{0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x30, 0x00, 0x02})
			buf.Write([]byte{0x02, 0x01, 0x01, 0x03, 0x00, 0xd9, 0x00, 0x06, 0x00, 0x02, 0x00, 0xa3, 0xc1, 0xc7, 0xf8, 0xa3, 0xb1, 0xb2, 0xe3, 0xdf, 0xc8, 0xb2, 0xb8, 0xd7, 0xdf, 0xc0, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x12, 0x13, 0x01, 0x08, 0x14})
			buf.Write([]byte{0x63, 0x23, 0x23})
			for range [3][]int{} {
				buf.Write([]byte{0x40, 0x40, 0x00, 0x00, 0x01, 0x01, 0x18, 0x0d, 0x11, 0x16, 0x0a, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buf.Write([]byte{0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x30, 0x00, 0x02})
				buf.Write([]byte{0x02, 0x01, 0x01, 0x03, 0x00, 0xd9, 0x00, 0x06, 0x00, 0x02, 0x00, 0xd5, 0xe2, 0xca, 0xc7, 0xd2, 0xbb, 0xb8, 0xf6, 0xd7, 0xaa, 0xc2, 0xeb, 0xb2, 0xe2, 0xca, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x12, 0x13, 0x01, 0x08, 0x14})
				buf.Write([]byte{0x68, 0x23, 0x23})
				time.Sleep(time.Millisecond * 10)
			}
		}()
		time.Sleep(time.Millisecond * 500)
		rd = nil
		runtime.GC()
		time.Sleep(time.Millisecond * 100)
		wg.Wait()
	})
}
