package utils_test

import (
	"encoding/binary"
	"testing"

	"github.com/shootingfans/codec_gb26875_3_2011/utils"

	"github.com/stretchr/testify/assert"
)

func TestB2S(t *testing.T) {
	b := []byte{0x61, 0x73, 0x64, 0x66, 0x31, 0x32, 0x33, 0x34, 0x35}
	assert.Equal(t, utils.B2S(b), "asdf12345")
}

func TestEncodeGB18030(t *testing.T) {
	b := []byte("物联网设备接入服务")
	assert.EqualValues(t, []byte{0xCE, 0xEF, 0xC1, 0xAA, 0xCD, 0xF8, 0xC9, 0xE8, 0xB1, 0xB8, 0xBD, 0xD3, 0xC8, 0xEB, 0xB7, 0xFE, 0xCE, 0xF1}, utils.EncodeGB18030(b))
}

func TestDecodeGB18030(t *testing.T) {
	b := []byte{0xCE, 0xEF, 0xC1, 0xAA, 0xCD, 0xF8, 0xC9, 0xE8, 0xB1, 0xB8, 0xBD, 0xD3, 0xC8, 0xEB, 0xB7, 0xFE, 0xCE, 0xF1, 0x00, 0x00, 0x00, 0x00}
	assert.EqualValues(t, []byte("物联网设备接入服务"), utils.DecodeGB18030(b))
}

func TestBytes2Int16(t *testing.T) {
	t.Run("test big order", func(t *testing.T) {
		assert.Equal(t, utils.Bytes2Int16([]byte{0xfe, 0x11}, binary.BigEndian), int16(-495))
	})
	t.Run("test little order", func(t *testing.T) {
		assert.Equal(t, utils.Bytes2Int16([]byte{0xfe, 0x11}, binary.LittleEndian), int16(4606))
	})
}

func TestSum(t *testing.T) {
	res := utils.Sum([]byte{0x18, 0x0d, 0x11, 0x16, 0x0a, 0x14, 0x30, 0x00, 0x02, 0x02, 0x01, 0x03, 0x00, 0xd9, 0x00, 0x06, 0x00, 0x02, 0x00, 0xa3, 0xc1, 0xc7, 0xf8, 0xa3, 0xb1, 0xb2, 0xe3, 0xdf, 0xc8, 0xb2, 0xb8, 0xd7, 0xdf, 0xc0, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x12, 0x13, 0x01, 0x08, 0x14})
	t.Run("test one sum", func(t *testing.T) {
		assert.True(t, res.Equal([]byte{0x50}, binary.BigEndian))
	})
	t.Run("test tow sum", func(t *testing.T) {
		res.Equal([]byte{0x0e, 0x50}, binary.BigEndian)
		assert.True(t, res.Equal([]byte{0x50, 0x0e}, binary.LittleEndian))
	})
	t.Run("test other length", func(t *testing.T) {
		assert.False(t, res.Equal([]byte{}, binary.BigEndian))
	})
}
